package io.github.freya022.botcommands.internal.core.db.traced

import io.github.freya022.botcommands.api.core.Logging.toUnwrappedLogger
import io.github.freya022.botcommands.api.core.db.query.ParametrizedQueryFactory
import io.github.freya022.botcommands.internal.core.db.DatabaseImpl
import io.github.freya022.botcommands.internal.utils.StackSensitive
import io.github.freya022.botcommands.internal.utils.findCaller
import kotlinx.coroutines.sync.Semaphore
import java.sql.Connection
import java.sql.PreparedStatement
import kotlin.time.Duration

@Suppress("SqlSourceToSinkFlow")
internal class TracedConnection internal constructor(
    connection: Connection,
    semaphore: Semaphore,
    private val parametrizedQueryFactory: ParametrizedQueryFactory<*>,
    private val logQueries: Boolean,
    private val isQueryThresholdSet: Boolean,
    private val queryLogThreshold: Duration
) : DatabaseImpl.ConnectionResource(connection, semaphore) {
    override fun prepareStatement(sql: String): PreparedStatement {
        return wrapStatement(connection.prepareStatement(sql), sql)
    }

    override fun prepareStatement(sql: String, columnNames: Array<out String>): PreparedStatement {
        return wrapStatement(connection.prepareStatement(sql, columnNames), sql)
    }

    override fun prepareStatement(sql: String, resultSetType: Int, resultSetConcurrency: Int): PreparedStatement {
        return wrapStatement(connection.prepareStatement(sql, resultSetType, resultSetConcurrency), sql)
    }

    override fun prepareStatement(sql: String, autoGeneratedKeys: Int): PreparedStatement {
        return wrapStatement(connection.prepareStatement(sql, autoGeneratedKeys), sql)
    }

    override fun prepareStatement(sql: String, columnIndexes: IntArray): PreparedStatement {
        return wrapStatement(connection.prepareStatement(sql, columnIndexes), sql)
    }

    override fun prepareStatement(sql: String, resultSetType: Int, resultSetConcurrency: Int, resultSetHoldability: Int): PreparedStatement {
        return wrapStatement(connection.prepareStatement(sql, resultSetType, resultSetConcurrency, resultSetHoldability), sql)
    }

    @OptIn(StackSensitive::class)
    private fun wrapStatement(preparedStatement: PreparedStatement, sql: String): PreparedStatement {
        val logger = findCaller(1).declaringClass.toUnwrappedLogger()
        return if (isQueryThresholdSet || (logQueries && logger.isTraceEnabled())) {
            val tracedQuery = parametrizedQueryFactory.get(preparedStatement, sql)
            TracedPreparedStatement(preparedStatement, logger, tracedQuery, logQueries, isQueryThresholdSet, queryLogThreshold)
        } else {
            preparedStatement
        }
    }
}